---
title: 设计模式之设计原则
date: 2024-04-03
categories:
  - 设计模式
tags:
  - 设计模式
published: true
---
# 1. 什么是设计模式
每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

## 1.1 设计思维
两个思维：底层思维和抽象思维
- 底层思维

向下，如何把握机器底层从微观理解对象构造
1. 语言构造
2. 编译转换
3. 内存模型
4. 运行时机制

- 抽象思维

向上，如何将我们的周围世界抽象为程序代码
1. 面向对象
2. 组件封装
3. 设计模式
4. 架构模式

# 2. 面向对象设计
## 2.1 实现层面
- 向下：深入理解三大面向对象机制

1. 封装：隐藏内部实现
2. 继承：复用现有代码
3. 多态：改写对象行为

- 向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”。

## 2.2 面向对象的设计
- 理解隔离变化

从宏观层面，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小。

- 各司其职

从微观层面，面向对象的方式更强调各个类的“责任”
由于需求变化导致的新增类型不应该影响原来类型的实现--是所谓各负其责。

- 对象是什么？

1. 从语言层面来看，对象封装了代码和数据
2. 从规格层面讲，对象是一系列可被使用的公共接口
3. 从概念层面讲，对象是某种拥有责任的抽象

## 2.3 参考资料
- **参考书籍**

《设计模式：可复用面向对象软件的基础》
《重构 -- 改善既有代码的设计》
《重构与模式》

# 3. 面向对象八大设计原则
面向对象共有八大设计原则，相对于设计模式，设计原则更加重要，因为设计模式相当于一种遵守设计原则的实现，如果某个设计模式违反了某个设计原则，这种设计模式将被淘汰。
通样，如果对设计原则有了更深入的理解，可以根据设计原则，自己设计一种设计模式。

## 3.1 依赖倒置原则（DIP）
依赖倒置原则的介绍：
1. 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
2. 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。

> 其中原则的核心就是，稳定的不能依赖变化的，否则在发生变化时，稳定的将也会变化，我们的目的是让变化尽量减少。


## 3.2 开放封闭原则（OCP）
开放封闭原则：
1. 对扩展开放，对更改封闭
2. 类模块应该是可扩展的，但是不可修改。

> 通过设计，应该在需要变化的时候，通过扩展的方式实现，而不是修改原有的设计。

## 3.3 单一职责原则（SRP）
1. 一个类应该仅有一个引起它变化的原因。
2. 变化的方向隐含着类的责任。

> 通过减少类所承担的责任，可以实现在相应“责任”所承担的功能发生变化时才需要修改。

## 3.4 LisKov 替换原则（LSP）
1. 子类必须能够替换它们的基类（IS-A）
2. 继承表达类型抽象

> 在使用继承时，要考虑比要性，是否子类和基类真的存在继承的关系，子类继承后，应该能完全表示基类，从而不会对基类有影响和修改。
> 如果不是真正的继承关系，可以考虑使用组合方式，在类中包含另一个类的对象。


## 3.5 接口隔离原则
1. 不应该强迫客户程序依赖它们不用的方法。
2. 接口应该小而完备

> 类设计应该考虑适用性，不能太臃肿，提供出去的接口一定是必要的，否则可以设置成private、protected的


## 3.6 优先使用对象组合，而不是类继承
1. 类继承通常为“白盒复用”，对象组合通常为“黑箱复用”
2. 继承在某种程度上破坏了封装性，子类父类耦合度高
3. 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

## 3.7 封装变化点
1. 使用封装来创建对象之间的分界层，让设计者可以在一侧进行修改，而不会对另一侧产生不良的影响


## 3.8 针对接口编程，而不是针对实现编程
1. 不将变量类型声明为某个特定的具体类，而是声明为某个接口
2. 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
3. 减少系统各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案

# 4. 设计模式分类和应用
## 4.1 模式分类
### 4.1.1 从目的来看

1. 创建型模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击
2. 结构型模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
3. 行为型模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击

### 4.1.2 从范围来看

1. 类模式处理类与子类的静态关系。
2. 对象模式处理对象间的动态关系

### 4.1.3 从封装变化角度对模式分类

![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240403145516.png)

1. 组件协作模式

现代软件行业分工之后的第一个结果是“框架与应用的划分”，“组件协作”模式通过晚绑定，来实现框架应用之间的松耦合，是二者之间协作时常用的模式。

**典型模式如下：**
- Template Method方法
- Strategy 策略模式
- Observer/Event 观察者模式

2. 单一职责模式

在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任

**典型模式如下：**
- Decorator 装饰模式
- Bridge 桥模式

3. 对象创建模式

通过“对象创建”模式绕开new，来避免对象创建（new）过程所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

**典型模式如下：**
- Factory Method 工厂模式
- Abstract Factory 抽象工厂
- Prototype 原型模式
- Builder 构建器模式

4. 对象性能

面向对象很好地解决了“抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

**典型模式如下：**
- Singleton 单件模式
- Flyweight 享元模式

5. 接口隔离

在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

**典型模式如下：**
- Facade 门面模式
- Proxy 代理模式
- Adapter 适配器
- Mediator 中介者

6. 状态变化

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

**典型模式如下：**
- State 状态模式
- Memento 备忘录

7. 数据结构

常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

**典型模式如下“**
- Composite 组合模式
- Iterator 迭代器模式
- Chain of Resposibility 职责链

8. 行为变化

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。

**典型模式如下：**
- Command 命令模式
- Visitor 访问器

9. 领域问题

在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，适合特定领域，将问题抽象为语法规则，从而给出该领域下的一般性解决方案。

**典型模式如下：**
- Interpreter 解析器
## 4.2 什么时候用设计模式？
1. 面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“应对变化，提高复用的设计”
2. 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点出应用设计模式，从而来更好地应对需求的变化”。“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。
3. 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的（重构获得模式）“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。

**重构关键技法：**
1. 静态 --》 动态
2. 早绑定 --》 晚绑定
3. 继承  --》 组合
4. 编译时依赖 --》 运行时依赖
5. 紧耦合  --》 松耦合












