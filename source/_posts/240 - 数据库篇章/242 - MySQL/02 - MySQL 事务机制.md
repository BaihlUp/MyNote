---
title: MySQL 事务机制
date: 2024-03-10
categories:
  - 数据库篇章
tags:
  - 数据库
  - MySQL
published: true
---
[TOC]
# 3 事务隔离
## 3.1 隔离性和隔离级别
- 事务的特性（ACID）
1. 原子性（Atomicity）
2. 一致性（Consistency）
3. 隔离性（Isolation）
4. 持久性（Durability）

## 3.2 SQL标准的事务隔离级别
- **读未提交**：一个事务还没提交时，他做的能被其他事务所看见
- **读提交**：一个事务提交之后，他做的修改才会被其他事务所看到
- **可重复读**：一个事务在执行期间看到的数据总是跟在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的
- **串行化**：“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才可以继续执行。

**示例：**
下边执行一个事务，如下的操作：
```sql
mysql> create table T(c int) engine=InnoDB; 
insert into T(c) values(1);
```
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/CCD503D7-DBD4-4988-86B1-EA829A207589.png)
- 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
- 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

### 3.2.1 查看和设置隔离级别
将启动参数transaction-isolation的值设置成READ-COMMITTED，则隔离级别会设置成“读提交”。可以使用show variables查看当前的值。
```bash
mysql> show variables like 'transaction_isolation'; 
+-----------------------+----------------+
| Variable_name | Value | 
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED | 
+-----------------------+----------------+
```

## 3.3 事务隔离级别的实现
在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上一个值，通过回滚操作，都可以得到前一个状态的值。
假设一个值从1被按顺序改成了2，3，4，在回滚日志中会有类似以下的记录：
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/648257AB-6A96-4D12-AF71-CD8AFDD1F91E.png)
回滚日志会存在到系统中，系统会判断什么时候可以删除。一般在没有比这个回滚日志更早的read-view的时候就可以删除了。
如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。
因为回滚日志是记录的这个事务的回滚操作，所以一定要避免使用长事务，长事务会导致回滚日志很大。

## 3.4 事务的启动方式
**事务有以下两种启动方式：**
- 显示启动事务语句，begin或start transaction。配套的提交语句commit，回滚语句rollback。
- set autocommit=0，这个命令将这个线程的自动提交关掉。意味着只执行select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或断开连接。

有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。
因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。

但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。

在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

### 3.4.1 查看长事务
在infomation_schema库的innodb_trx表中查看，比如下面这个语句，用于查找持续时间超过60s的事务。
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 3.4.2 如何避免长事务对业务的影响？
- **应用开发方面：**
1. 确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。
2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间

- **数据库端：**
1. 监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill；
2. Percona的pt-kill这个工具不错，推荐使用；
3. 在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；
4. 如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。

**参考资料：**
[开启General_log](https://app.yinxiang.com/shard/s16/nl/19257560/af1e9c7a-b728-4d2c-b0e2-3ffed86bfeb1)

# 8 事务隔离的实现
如下是一个建表示例：
```sql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/A7472FC3-71BC-4B81-B987-D7E20E838B60.png)
上边A、B、C三个事务执行时，begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。
默认autocommit=1。在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。
上例中事务B查到的k的值是3，而事务A查到的k的值是1，下边我们就来解释三个事务的执行逻辑和锁之间的关系。

在MySQL里，有两个“视图”的概念：

* 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。
* 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

## 8.1 “快照”在MVCC里是怎么工作的？
在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。
快照并不是把数据拷贝备份一下，否则如果有个100G大小的库，那是不可能实现的。
InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。
而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。
也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。
如图所示，就是一个记录被多个事务连续更新后的状态。
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/70B57638-5D5A-4DDF-9120-FA9D29D59EC5.png)
图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。
你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，undo log在哪呢？
实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。

事务的可重复读实现，一个事务启动的时候会看到当前所有已提交的事务结果，但是，这个事务在执行期间，其他事务的更新他就不可见了。所以事务会以启动时为准，如果一个数据是在启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。
在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。
数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。
这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。
而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。
这个视图数组把所有的row trx_id 分成了几种不同的情况。
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/A10CF39E-8EFB-405D-8566-EE066D28F7DB.png)
这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：
1.  如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
 2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
    a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

> InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

接下来，我们继续看一下之前图中的三个事务，分析下事务A的语句返回的结果，为什么是k=1。
这里，我们不妨做如下假设：

1. 事务A开始前，系统里面只有一个活跃事务ID是99；
2. 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；
3. 三个事务开始前，(1,1）这一行数据的row trx_id是90。

这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。
为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/BD5EB53B-8492-4DFA-9913-52985CFBB0E6.png)
对于事务B在查找K的值时，会根据自己数组的范围，应该取的是小于99并且在已提交事务的列表里的版本，虽然在事务A的执行过程中，K的版本被事务B和事务C都修改过，但是对于事务A来说，新版本的K是不可见的。
事务A查询语句的读数据流程是这样的：

* 找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见；
* 接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见；
* 再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

## 8.2 更新逻辑
下边来分析为什么事务B的k的结果为3。
与事务A的差异就在于，事务B是更新操作，事务A是查询操作。
事务B要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。
这里就用到了这样一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）**。
因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。
所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。
这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。
所以，如果把事务A的查询语句select * from t where id=1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。
```
mysql> select k from t where id=1 lock in share mode; 
mysql> select k from t where id=1 for update;
```

下边修改一个三个事务的执行逻辑：
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/9A56DADB-8164-428C-9ABF-D20AB8542C60.png)
与之前不同的是，事务C执行完之后并没有立即提交，而是在事务B执行更新之后提交的。
这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/A4C50C5C-85B6-4528-AB5D-723BC32048A8.png)

> 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

**而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是**：

* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
* 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？
这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。

下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）

![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/0C9DB43C-F43E-4DEA-A6E7-0570694B6DA1.png)
这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：
* (1,3)还没提交，属于情况1，不可见；
* (1,2)提交了，属于情况3，可见。

所以，这时候事务A查询语句返回的是k=2。

显然地，事务B查询结果k=3。

## 8.3 总结
InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。

对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
对于读提交，查询只承认在语句启动前就已经提交完成的数据；
当前读，总是读取已经提交完成的最新版本。

## 8.4 问题
如下思考一个问题，用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。
```
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);
```
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/E0A706BE-19EE-4B97-9B79-011D2917DA17.png)
构造出以上的情况

答案：
语句执行顺序如下：
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/BB0696B1-1B98-4CC1-9141-D0AD2CC73D75.png)

B在执行的是否被锁住
![](https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/1CA03BCD-F7F0-4DAD-8EEE-59FE65986846.png)
以上执行时，B比A启动早，对A来说，B不可见。




